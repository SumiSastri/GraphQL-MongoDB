- [Instructor] So back in our server spec let's fix our calculator test and change it's to be to four. Now let's describe another set of tests. This time it'll be specific to get messages. So all the test part of this group will test various features of our get messages endpoint. So let's create our first test or specification. It should return 200 ok. So we expect that the status code of get messages will be 200 ok not 500 if there is a server error not 401 for not found, etc and then let's add a call back. So inside here we actually need to make an HTTP get request. Natively we can't do that so we'll have to use a library called request. So let's install that with npm install - - save - dev request and at the top let's require it in. Then we'll use request.get and we'll specify our URL and then a call back. The call back will contain an error and the response. For now we'll console log the response to make sure we're actually getting a response. At this point we'll have to start our server so we use nodemon and it started our server. Now let's open up a new terminal and we'll use npm test. We can see that two specs passed, but we didn't see our response console logged. That's because this test ends before we even get a call back. The reason for that is because it's not set as asynchronous. So to do that with Jasmine inside the spec definition. We need to pass back done and then we need to call done whenever our asynchronous code finishes. Let's give that another try. Now if we scroll up we can see our response. Let's try console logging the response.body, and we can see our messages. So now let's create our first expect. So we're checking that response.status code is equal to 200, and I'll take out the console log, save that, and let's try running it. We can see two tests passed. Let's create another test spec. So I'll copy the first it from line 10 to line 15 and paste it below. In here we'll check that it returns a list that's not empty. It should return a list that's not empty. Then let's change our expect. So we'll check the response.body .length to be greater than zero. That made the array inside the body that needs to be greater than zero or not empty and since we know there are two messages they should pass. So I'll save this and let's run our test, and it's passing, but just to try something else I'll check if it's greater than 40. Let's try that. And even though I set it to 40 yet we know we only have two items inside our message array somehow it's still passing. In this case even though I thought I was testing something I was actually testing something completely different and if we remember our response.body is a string by default. So really I was testing the length of the amount of characters in that string, which is roughly around 70 or 80. So a good idea is to actually get your tests to fail first that way it further reinforces that you're actually testing the right thing and this is a concept we'll get into in test driven development in the next video, but for now what we're going to do is convert this over to JSON first with JSPON parse we'll wrap the body and we'll get the length of that JSON, and since that JSON will be an array this should work and by work I mean it should fail. So let's try it and there we go expected two to be greater than 40. So now let's switch it back to zero and it should pass. Now that we have an idea of how we can apply tests to our existing application features to verify that they are working and will continue to work as we develop new features let's take a quick look at how we can develop new features in our app using test first or test driven development.

- [Narrator] In this video, we'll add a new feature using test-driven development. So we'll add a test first, we'll make it fail and then we'll implement the feature to make the test pass. The new feature we'll add is a new messages get call, or endpoint that will allow us to get the messages from a specific owner, by checking the name. And we'll get that name through a URL parameter. So let's begin by creating a test. We'll start running new describe. And these tests will revolve around getting messages from a specific user. The first test will be the standard, it should return a 200 okay, so I'll just copy this from above from line 10 through line 15 and paste it in our new describe. Next, I'll need to supply a user name at the end of the Url and I'll just use Tim. Let's save that and give it a try. We'll use npm test. We can see there were four specs that were run and one that failed. Our get messages from user should return 200 okay and we got a 404, not found that we expected, to equal 200. And so that's good. The route doesn't exist yet and we should get 404's. So it is failing just like we expect. Now let's go ahead and make that pass. So let's go to our server js and copy our app.get messages function and paste it below. Then let's add a user parameter. Now that I've added the user parameter, that should be it. Let's try and see if our test passed. Now that we ran our test, we can see it's passed. It did find the route and regardless of what was sent to us back, our test passed. But we don't know if it actually functions as expected because our full requirement is that it only gives us messages of a specified user. So let's create another specification for that. We'll check that the name should be Tim. And we'll copy the request call between line 26 and 29 and paste it inside. Then let's check the response.body. And as before, we'll need to convert it to JSON. Then we'll get the first element in our array and check the name, and make sure that it's equal to Tim. We'll save that. And before we run it, think of whether it will work or will fail, let's give it a try. And it's failed. That's because the messages we currently have in our database aren't guaranteed to be posted by Tim. Second of all, we don't have the functionality yet in our server, to support that specification. We're just returning all of the messages. Let's go ahead and implement the functionality to make this pass. First thing we'll need to do is get access to that user parameter. So we'll create a variable, called User, set it to request.params.user. And then we'll select all of our messages if the name matches the user. Now once again, if we run this, think whether it will fail or pass. And it failed. And it cannot read property name of undefined. Why is that? Since we're only getting back messages that the user Tim owns, we currently don't have any messages by Tim and so we're getting back nothing in our array and it's failing as a result. So at this point, let's go back to our app and post a new message by Tim. And now let's try running our test again. And it's passed. It's not ideal that we have to actually set the state of our database in our server in order for our test to pass. The ideal thing would be that our test suite sets up the server and the database just the way it should be before the tests are run. And in more advanced testing, that's exactly what we would do. We'd have a before function that executes at the start of our test or test suites, that sets up the database with say, a message from Tim. The test then executes and then an after function would execute and remove that message, therefore returning the database back to a normal state. And those are some of the important concepts of testing and test-driven development. At this point, we've developed a feature in our application by writing tests for it first. Let's go to our browser and try it out for ourselves. And we can see, it's working. And that's the basic process of test-driven development. Next, let's take a look at some of the things we've covered in this course and where you can go from here.

- [Instructor] So back in our server spec let's fix our calculator test and change it's to be to four. Now let's describe another set of tests. This time it'll be specific to get messages. So all the test part of this group will test various features of our get messages endpoint. So let's create our first test or specification. It should return 200 ok. So we expect that the status code of get messages will be 200 ok not 500 if there is a server error not 401 for not found, etc and then let's add a call back. So inside here we actually need to make an HTTP get request. Natively we can't do that so we'll have to use a library called request. So let's install that with npm install - - save - dev request and at the top let's require it in. Then we'll use request.get and we'll specify our URL and then a call back. The call back will contain an error and the response. For now we'll console log the response to make sure we're actually getting a response. At this point we'll have to start our server so we use nodemon and it started our server. Now let's open up a new terminal and we'll use npm test. We can see that two specs passed, but we didn't see our response console logged. That's because this test ends before we even get a call back. The reason for that is because it's not set as asynchronous. So to do that with Jasmine inside the spec definition. We need to pass back done and then we need to call done whenever our asynchronous code finishes. Let's give that another try. Now if we scroll up we can see our response. Let's try console logging the response.body, and we can see our messages. So now let's create our first expect. So we're checking that response.status code is equal to 200, and I'll take out the console log, save that, and let's try running it. We can see two tests passed. Let's create another test spec. So I'll copy the first it from line 10 to line 15 and paste it below. In here we'll check that it returns a list that's not empty. It should return a list that's not empty. Then let's change our expect. So we'll check the response.body .length to be greater than zero. That made the array inside the body that needs to be greater than zero or not empty and since we know there are two messages they should pass. So I'll save this and let's run our test, and it's passing, but just to try something else I'll check if it's greater than 40. Let's try that. And even though I set it to 40 yet we know we only have two items inside our message array somehow it's still passing. In this case even though I thought I was testing something I was actually testing something completely different and if we remember our response.body is a string by default. So really I was testing the length of the amount of characters in that string, which is roughly around 70 or 80. So a good idea is to actually get your tests to fail first that way it further reinforces that you're actually testing the right thing and this is a concept we'll get into in test driven development in the next video, but for now what we're going to do is convert this over to JSON first with JSPON parse we'll wrap the body and we'll get the length of that JSON, and since that JSON will be an array this should work and by work I mean it should fail. So let's try it and there we go expected two to be greater than 40. So now let's switch it back to zero and it should pass. Now that we have an idea of how we can apply tests to our existing application features to verify that they are working and will continue to work as we develop new features let's take a quick look at how we can develop new features in our app using test first or test driven development.
